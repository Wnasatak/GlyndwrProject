package assignment1.krzysztofoko.s16001089.ui.auth

import android.content.Context
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import assignment1.krzysztofoko.s16001089.data.AppDatabase
import assignment1.krzysztofoko.s16001089.data.SystemLog
import assignment1.krzysztofoko.s16001089.data.UserLocal
import assignment1.krzysztofoko.s16001089.utils.EmailUtils
import com.google.firebase.auth.AuthCredential
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseAuthUserCollisionException
import kotlinx.coroutines.launch

/**
 * ViewModel responsible for managing the authentication state and business logic.
 * It handles login, registration, password reset, and two-factor authentication flows.
 */
class AuthViewModel(private val db: AppDatabase) : ViewModel() {
    // Instance of Firebase Auth for cloud-based identity management
    private val auth = FirebaseAuth.getInstance()

    // --- Form State: Tracks user inputs in the authentication forms ---
    var email by mutableStateOf("") // Current email address input
    var password by mutableStateOf("") // Current password input
    var firstName by mutableStateOf("") // Current first name input (used for registration)
    var passwordVisible by mutableStateOf(false) // Toggles password mask visibility in the UI
    
    // --- Navigation & UI Flow State: Controls which step of the auth process is displayed ---
    var isLogin by mutableStateOf(true) // Toggles between Login and Registration UI
    var isVerifyingEmail by mutableStateOf(false) // Indicates the user is at the email verification step
    var isResettingPassword by mutableStateOf(false) // Indicates the user is at the password recovery step
    var isTwoFactorStep by mutableStateOf(false) // Indicates the user is entering their 2FA code
    var isAuthFinalized by mutableStateOf(false) // Set to true after all security checks are passed
    
    // --- 2FA State: Manages the lifecycle of the security code ---
    var entered2FACode by mutableStateOf("") // Stores the 6-digit code typed by the user
    var generated2FACode by mutableStateOf("") // Stores the random code generated by the system
    
    // --- Popups & Feedback: Controls informative UI overlays ---
    var showDemoPopup by mutableStateOf(false) // Shows the generated code in a popup for demo/testing
    var showSuccessPopup by mutableStateOf(false) // Shows the final success confirmation modal
    var isLoading by mutableStateOf(false) // Controls global loading indicators
    var error by mutableStateOf<String?>(null) // Holds error messages for display in the UI
    
    // --- Security & Session: Tracks login attempt metadata ---
    var loginAttempts by mutableIntStateOf(0) // Counter for failed sign-in attempts
    var pendingAuthResult by mutableStateOf<Pair<String, UserLocal?>?>(null) // Holds user data between auth steps

    /**
     * Internal utility to create a security log entry in the system audit trail.
     */
    private fun addLog(userId: String, userName: String, action: String, details: String, role: String = "user") {
        viewModelScope.launch {
            val type = if (role == "admin") "ADMIN" else "USER"
            db.auditDao().insertLog(SystemLog(
                userId = userId,
                userName = userName,
                action = action,
                targetId = "AUTH",
                details = details,
                logType = type
            ))
        }
    }

    /**
     * Determines if an email should bypass verification requirements for testing.
     * This is useful for development and demonstration purposes.
     */
    private fun isBypassEmail(email: String?): Boolean {
        if (email == null) return false
        val bypassList = listOf("teacher@example.com", "admin@example.com", "student@example.com", "user@example.com") 
        return bypassList.contains(email.lowercase())
    }

    /**
     * Initiates the 2FA process by generating a code and sending it via email.
     */
    fun trigger2FA(context: Context, userEmail: String, onCodeSent: (String) -> Unit) {
        isLoading = true
        val code = (100000..999999).random().toString() // Generate a random 6-digit number
        generated2FACode = code
        
        viewModelScope.launch {
            try {
                // Use the utility to send the code through the device's mail service
                val success = EmailUtils.send2FACode(context, userEmail, code)
                if (success) {
                    isTwoFactorStep = true // Advance to the code entry screen
                    showDemoPopup = true // Display the code for demo convenience
                    onCodeSent(userEmail) // Notify the UI that dispatch was successful
                } else {
                    error = "Failed to send verification code."
                }
            } catch (e: Exception) {
                error = "Error: ${e.localizedMessage}"
            } finally {
                isLoading = false
            }
        }
    }

    /**
     * Persists the user data to the local database after successful verification.
     * This finalizes the authentication journey.
     */
    fun finalizeAuth() {
        isLoading = true
        viewModelScope.launch {
            try {
                pendingAuthResult?.let { (_, localUser) ->
                    localUser?.let { 
                        // Update the local Room database with the synchronized user profile
                        db.userDao().upsertUser(it)
                        val action = when(it.role) {
                            "admin" -> "ADMIN_LOGIN"
                            "teacher" -> "TUTOR_LOGIN"
                            else -> "USER_LOGIN"
                        }
                        // Record the successful login event
                        addLog(it.id, it.name, action, "Successful authentication and session start.", it.role)
                    }
                    isAuthFinalized = true // Mark the entire flow as complete
                    showSuccessPopup = true // Trigger the success animation/modal
                    isTwoFactorStep = false // Close the 2FA input
                }
            } catch (e: Exception) {
                error = "Finalization failed."
            } finally {
                isLoading = false
            }
        }
    }

    /**
     * Primary handler for standard Email/Password sign-in.
     */
    fun handleSignIn(context: Context, onCodeSent: (String) -> Unit) {
        val trimmedEmail = email.trim()
        if (trimmedEmail.isEmpty() || password.isEmpty()) {
            error = "Fields cannot be empty."
            return
        }
        isLoading = true
        // Authenticate with Firebase first
        auth.signInWithEmailAndPassword(trimmedEmail, password)
            .addOnSuccessListener { res ->
                val user = res.user
                loginAttempts = 0 // Reset attempt counter
                
                // Proceed only if the email is verified or belongs to the bypass list
                if (user?.isEmailVerified == true || isBypassEmail(user?.email)) {
                    viewModelScope.launch {
                        val existing = db.userDao().getUserById(user!!.uid)
                        
                        // Check for administrative access based on email or existing DB role
                        val updatedRole = when (user.email) {
                            "prokocomp@gmail.com", "admin@example.com" -> "admin"
                            else -> (existing?.role ?: "user")
                        }
                        
                        // Construct the local user profile
                        val userData = UserLocal(
                            id = user.uid,
                            name = existing?.name ?: user.displayName ?: when(user.email) {
                                "admin@example.com" -> "System Admin"
                                "teacher@example.com" -> "Senior Tutor"
                                "student@example.com" -> "Sample Student"
                                else -> "User"
                            },
                            email = user.email ?: trimmedEmail,
                            balance = existing?.balance ?: 0.0,
                            role = updatedRole,
                            photoUrl = existing?.photoUrl ?: user.photoUrl?.toString(),
                            address = existing?.address,
                            phoneNumber = existing?.phoneNumber,
                            selectedPaymentMethod = existing?.selectedPaymentMethod
                        )
                        pendingAuthResult = "" to userData // Store context for the 2FA step
                        trigger2FA(context, trimmedEmail, onCodeSent) // Trigger the security code
                    }
                } else {
                    // Send verification link if the email has not been confirmed yet
                    isVerifyingEmail = true
                    user?.sendEmailVerification()
                    isLoading = false
                }
            }
            .addOnFailureListener {
                isLoading = false
                loginAttempts++
                error = "Login failed. Please check your credentials."
            }
    }

    /**
     * Primary handler for new account registration.
     */
    fun handleSignUp() {
        val trimmedEmail = email.trim()
        if (trimmedEmail.isEmpty() || password.isEmpty() || firstName.isEmpty()) {
            error = "Fields cannot be empty."
            return
        }
        isLoading = true
        // Create user in Firebase Cloud
        auth.createUserWithEmailAndPassword(trimmedEmail, password)
            .addOnSuccessListener { res ->
                val user = res.user!!
                viewModelScope.launch {
                    // Determine initial role assignment
                    val assignedRole = when (trimmedEmail) {
                        "prokocomp@gmail.com", "admin@example.com" -> "admin"
                        else -> "user" 
                    }
                    
                    val userData = UserLocal(
                        id = user.uid,
                        name = firstName,
                        email = trimmedEmail,
                        balance = 0.0,
                        role = assignedRole
                    )
                    pendingAuthResult = "" to userData
                    // Log the registration event
                    addLog(user.uid, firstName, "USER_SIGN_UP", "New user registered: $trimmedEmail", userData.role)
                    
                    // Request email verification from Firebase
                    user.sendEmailVerification()
                    isVerifyingEmail = true // Move to check-inbox UI
                    isLoading = false
                }
            }
            .addOnFailureListener { e ->
                isLoading = false
                if (e is FirebaseAuthUserCollisionException) {
                    error = "This email is already registered. Please sign in instead."
                } else {
                    error = e.localizedMessage
                }
            }
    }

    /**
     * Handles authentication via Google OAuth credentials.
     */
    fun handleGoogleSignIn(credential: AuthCredential, idToken: String, context: Context, onCodeSent: (String) -> Unit) {
        isLoading = true
        // Sign in to Firebase with the Google credential
        auth.signInWithCredential(credential)
            .addOnSuccessListener { res ->
                val user = res.user!!
                viewModelScope.launch {
                    val existing = db.userDao().getUserById(user.uid)
                    
                    val updatedRole = when (user.email) {
                        "prokocomp@gmail.com", "admin@example.com" -> "admin"
                        else -> (existing?.role ?: "user")
                    }

                    // Prepare metadata for local persistence
                    val userData = UserLocal(
                        id = user.uid,
                        name = existing?.name ?: user.displayName ?: "User",
                        email = user.email ?: "",
                        photoUrl = existing?.photoUrl ?: user.photoUrl?.toString(),
                        balance = existing?.balance ?: 0.0,
                        role = updatedRole,
                        address = existing?.address,
                        phoneNumber = existing?.phoneNumber,
                        selectedPaymentMethod = existing?.selectedPaymentMethod
                    )
                    pendingAuthResult = idToken to userData
                    trigger2FA(context, user.email ?: "", onCodeSent) // Ensure 2FA consistency
                }
            }
            .addOnFailureListener { e ->
                isLoading = false
                error = "Google Authentication failed."
            }
    }

    /**
     * Triggers the Firebase password recovery flow.
     */
    fun resetPassword() {
        if (email.trim().isEmpty()) {
            error = "Email is required for password reset."
            return
        }
        isLoading = true
        // Request password reset email from Firebase
        auth.sendPasswordResetEmail(email.trim())
            .addOnSuccessListener {
                isLoading = false
                error = "Reset link sent to your email!"
            }
            .addOnFailureListener {
                isLoading = false
                error = "Failed to send reset link. Check if the email is correct."
            }
    }
    
    /**
     * Gracefully ends the user session and logs the event.
     */
    fun signOut(localUser: UserLocal?) {
        val uid = localUser?.id ?: auth.currentUser?.uid ?: "unknown"
        val name = localUser?.name ?: auth.currentUser?.displayName ?: "User"
        val role = localUser?.role ?: "user"
        val action = when(role) {
            "admin" -> "ADMIN_LOGOUT"
            "teacher" -> "TUTOR_LOGIN"
            else -> "USER_LOGOUT"
        }
        // Audit log for security tracking
        addLog(uid, name, action, "User signed out from the session.", role)
        auth.signOut() // Kill the Firebase session
    }
}
